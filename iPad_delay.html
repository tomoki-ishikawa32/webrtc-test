<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>iPad 映像受信（Canvas遅延）</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      background-color: black;
      overflow: hidden;
      height: 100%;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      background-color: black;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background-color: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 8px;
    }
    textarea {
      width: 90vw;
      max-width: 600px;
    }
    video {
      display: none;
    }
  </style>
</head>
<body>

<video id="remoteVideo" autoplay playsinline muted></video>
<canvas id="delayedCanvas" width="1280" height="720"></canvas>

<div id="controls">
  <h3>iPad 映像受信（5秒遅延）</h3>
  <textarea id="offer" placeholder="Paste Offer SDP here" rows="8"></textarea><br>
  <button id="setOffer">Set Offer</button><br><br>
  <textarea id="answer" placeholder="Answer SDP" rows="8" readonly></textarea><br>
</div>

<script>
  let pc;
  let video = document.getElementById('remoteVideo');
  let canvas = document.getElementById('delayedCanvas');
  let ctx = canvas.getContext('2d');
  let frameBuffer = [];
  const DELAY_SECONDS = 5;
  const FPS = 10;
  const MAX_FRAMES = DELAY_SECONDS * FPS;

  document.getElementById('setOffer').onclick = async () => {
    const offerSDP = JSON.parse(document.getElementById('offer').value);
    pc = new RTCPeerConnection();

    pc.ontrack = (event) => {
      video.srcObject = event.streams[0];
      startBuffering();
    };

    pc.onicecandidate = (event) => {
      if (event.candidate === null) {
        document.getElementById('answer').value = JSON.stringify(pc.localDescription);
      }
    };

    await pc.setRemoteDescription(new RTCSessionDescription(offerSDP));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
  };

  function startBuffering() {
    // フレーム保存用タイマー（リアルタイム録画）
    setInterval(() => {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      frameBuffer.push(frame);
      if (frameBuffer.length > MAX_FRAMES) {
        frameBuffer.shift(); // 古いフレームを削除してバッファを維持
      }
    }, 1000 / FPS);

    // 遅延描画タイマー
    setInterval(() => {
      if (frameBuffer.length >= MAX_FRAMES) {
        const frame = frameBuffer.shift(); // 古いフレームから描画
        ctx.putImageData(frame, 0, 0);
      }
    }, 1000 / FPS);
  }
</script>
</body>
</html>
